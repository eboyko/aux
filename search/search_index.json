{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"pluggable.html","title":"The Pluggable","text":""},{"location":"pluggable.html#convention-and-restrictions","title":"Convention and restrictions","text":"<p>Your application needs to use Zeitwerk as a code loader and follow its file structure conventions. It would help to find correct classes and their files when resolving dependencies. The latest version of Rails uses it by default, so this shouldn't be a problem.</p>"},{"location":"pluggable.html#the-cipher-convention","title":"The cipher convention","text":"<p>The key principle of the Pluggable module is the cipher. Each dependency must provide its cipher to be registered.</p> <p>By default, the cipher is generated using the full class name. Converting the class name to the cipher is simple: camel case is converted to snake case, and separators are replaced with dots.</p> <p>For example, the class <code>Billing::Enterprise::CreateInvoiceService</code> gets the cipher of <code>billing.enterprise.create_invoice_service</code>. Characters before the last dot (<code>billing.enterprise</code>) are scope, after the last dot <code>create_invoice_service</code> are code.</p> <p>The <code>UsersRepository</code> class gets the cipher <code>users_repository</code>. It has no scope, only code.</p>"},{"location":"pluggable.html#setup","title":"Setup","text":"<p>Create an initializer file. Link the <code>Dry::Container</code> instance as the registry manager. Use the existing one if you have one in your application; this allows pluggable classes to use existing dependencies. Otherwise, initialize a new one.</p> config/initializers/pluggable.rb<pre><code>Aux::Pluggable.registry = Dry::Container.new\n</code></pre> <p>Use this file to build and register any dependencies that cannot be initialized within dedicated classes:</p> config/initializers/pluggable.rb<pre><code>Aux::Pluggable.registry = Dry::Container.new\nAux::Pluggable.registry.register(:settings, memoize: true) do\nYAML.load_file(Rails.root.join('config/settings.yml'))\nend\n</code></pre>"},{"location":"pluggable.html#registration","title":"Registration","text":"<p>The <code>register</code> method adds the dependency to the registry. This method can take two optional arguments: <code>initialize</code> and <code>memoize</code>. The argument names are self-explanatory, but here are some examples to better understand the behavior.</p>"},{"location":"pluggable.html#static-class","title":"Static class","text":"app/repositories/users_repository.rb<pre><code>class UsersRepository\ninclude Aux::Pluggable\nregister\nend\n</code></pre> irb<pre><code>irb(main):001:0&gt; puts Aux::Pluggable.registry.resolve(:users_repository)\n=&gt; UsersRepository\n</code></pre>"},{"location":"pluggable.html#instance","title":"Instance","text":"app/repositories/users_repository.rb<pre><code>class UsersRepository\ninclude Aux::Pluggable\nregister initialize: true\nend\n</code></pre> irb<pre><code>irb(main):001:0&gt; puts Aux::Pluggable.registry.resolve(:users_repository)\n=&gt; #&lt;UsersRepository:0x0000557eb24807e8&gt;\nirb(main):002:0&gt; puts Aux::Pluggable.registry.resolve(:users_repository)\n=&gt; #&lt;UsersRepository:0x000055d96dd9db30&gt;\n</code></pre>"},{"location":"pluggable.html#memoized-instance","title":"Memoized instance","text":"app/repositories/users_repository.rb<pre><code>class UsersRepository\ninclude Aux::Pluggable\nregister initialize: true, memoize: true\nend\n</code></pre> irb<pre><code>irb(main):001:0&gt; puts Aux::Pluggable.registry.resolve(:users_repository)\n=&gt; #&lt;UsersRepository:0x00005612bc432748&gt;\nirb(main):002:0&gt; puts Aux::Pluggable.registry.resolve(:users_repository)\n=&gt; #&lt;UsersRepository:0x00005612bc432748&gt;\n</code></pre>"},{"location":"pluggable.html#experimental-features","title":"Experimental features","text":"<p>There are also two experimental arguments that provide a way to register the dependency with the cipher that does not match its class name. This feature may only work if eager class loading is enabled. Do not use it unless you know what you are doing.</p>"},{"location":"pluggable.html#code-specification","title":"Code specification","text":"app/repositories/users_repository.rb<pre><code>class UsersRepository\ninclude Aux::Pluggable\nregister as: :employees_repository # (1)\nend\n</code></pre> <ol> <li>It registers the current class with the cipher <code>employees_repository</code>. Attempting to resolve the <code>users_repository</code> cipher will fail.</li> </ol> irb<pre><code>irb(main):001:0&gt; puts Aux::Pluggable.registry.resolve('employees_repository')\n=&gt; UsersRepository\n</code></pre>"},{"location":"pluggable.html#scope-specification","title":"Scope specification","text":"app/repositories/users_repository.rb<pre><code>class UsersRepository\ninclude Aux::Pluggable\nregister scope: :core # (1)\nend\n</code></pre> <ol> <li>It registers the current class with the cipher <code>core.users_repository</code>. Attempting to resolve the <code>users_repository</code> cipher will fail.</li> </ol> irb<pre><code>irb(main):001:0&gt; puts Aux::Pluggable.registry.resolve('core.users_repository')\n=&gt; UsersRepository\n</code></pre>"},{"location":"pluggable.html#resolving","title":"Resolving","text":"<p>The <code>resolve</code> method is much more powerful to satisfy a wide range of developer needs. It takes at least one argument: the required dependency cipher.</p> <p>NB! A class that uses dependency resolution feature may or may not be registered.</p> app/services/create_user_service.rb<pre><code>class CreateUserService\ninclude Aux::Pluggable\nresolve :users_repository\ndef call(**attributes)\nusers_repository.create!(**attributes)\nend\nend\n</code></pre>"},{"location":"pluggable.html#pre-injection-handling","title":"Pre-injection handling","text":"<p>The second positional argument is reserved for a proc that handles the dependency before injection. You can use this feature to filter any extensive data for the concrete case.</p> app/services/create_user_service.rb<pre><code>class CreateUserService\ninclude Aux::Pluggable\nresolve :users_repository\nresolve :preferences, -&gt; (preferences) { preferences.fetch(:default) }\ndef call(**attributes)\nusers_repository.create!(**attributes, preferences: preferences)\nend\nend\n</code></pre>"},{"location":"pluggable.html#internal-name-specification","title":"Internal name specification","text":"<p>Passing the <code>as</code> argument allows you to specify the internal dependency name (e.g., instance variable name as well as attribute reader method name).</p> app/services/create_user_service.rb<pre><code>class CreateUserService\ninclude Aux::Pluggable\nresolve :users_repository, as: :repository\nresolve :preferences, -&gt; (preferences) { preferences.fetch(:default) }, as: :default_preferences\ndef call(**attributes)\nrepository.create!(**attributes, preferences: default_preferences)\nend\nend\n</code></pre>"},{"location":"pluggable.html#scope-specification_1","title":"Scope specification","text":"<p>By default, the resolver looks for dependencies in the namespace of the current class. When resolving a dependency from the foreign namespace, you must specify the <code>scope</code> argument for proper behavior.</p> app/services/finance/create_invoice_service.rb<pre><code>module Finance\nclass CreateInvoiceService\ninclude Aux::Pluggable\nresolve :invoices_repository # (1)\nresolve :goods_repository, scope: :store # (2)\nresolve :users_repository, scope: nil # (3)\nend\nend\n</code></pre> <ol> <li>Resolves the <code>Finance::InvoicesRepository</code>, which is in the same namespace.</li> <li>Resolves the <code>Store::GoodsRepository</code>, which is in a foreign namespace.</li> <li>Resolves the <code>UsersRepository</code>, which is in the root namespace.</li> </ol>"},{"location":"pluggable.html#visibility-control","title":"Visibility control","text":"<p>By default, the dependency can only be accessed privately. The <code>private</code> argument allows you to override the visibility of the resolved dependency.</p>"},{"location":"pluggable.html#private","title":"Private","text":"app/services/create_user_service.rb<pre><code>class CreateUserService\ninclude Aux::Pluggable\nresolve :users_repository\nend\n</code></pre> irb<pre><code>irb(main):001:0&gt; puts Aux::Pluggable.registry.resolve(:create_user_service).users_repository\n=&gt; NoMethodError: private method `users_repository` called for CreateUserService:Class\n</code></pre>"},{"location":"pluggable.html#public","title":"Public","text":"app/services/create_user_service.rb<pre><code>class CreateUserService\ninclude Aux::Pluggable\nresolve :users_repository, private: false\nend\n</code></pre> irb<pre><code>irb(main):001:0&gt; puts Aux::Pluggable.registry.resolve(:create_user_service).users_repository\n=&gt; UsersRepository\n</code></pre>"},{"location":"pluggable.html#custom-initialization","title":"Custom initialization","text":"<p>You have control over the initialization of your class as if you were not using the Pluggable module, but with one advantage: resolved dependencies are available during the initialization.</p> <p>Of course, it makes no sense to use the <code>register</code> method for such kind of classes. Register them using a proper initializer file like <code>config/initializers/pluggable.rb</code>.</p> <p>Warning</p> <p>Keep two things in mind to avoid confusion. Do not pass keyword arguments that are named exactly like resolved dependencies. Do not modify instance variables and attribute reader methods of resolved dependencies to preserve their original functionality.</p> app/services/weather_forecast_service.rb<pre><code>class WeatherForecastService\ninclude Aux::Pluggable\nresolve :local_provider\nresolve :global_provider\ndef initialize(locations_file_path, excepted_locations_ids: [])\n@forecasts = []\nYAML.load_file(locaions_file_path).each do |location|\nnext if excepted_locations_ids.include?(location.id)\nforecast = local_provider.fetch(location) || global_provider.fetch(location)\n@forecasts.push(forecast)\nend\nend\nend\n</code></pre>"},{"location":"pluggable.html#testing","title":"Testing","text":""},{"location":"pluggable.html#static-class_1","title":"Static class","text":"<p>Static classes do not inherently support dependency injection. It is not a good idea to mock the dependencies of a static class. If you absolutely must, the gentle way to mock the dependencies of a static class would be to mock the registry.</p> spec/support/shared_contexts/registry.rb<pre><code>let(:registry) { double(:registry) }\nbefore do\nAux::Pluggable.registry = registry\nend\n</code></pre> spec/services/create_user_service_spec.rb<pre><code>let(:users_repository) { double(:users_repository) }\nbefore do\nallow(registry).to receive(:resolve).with(:users_repository).and_return(users_repository)\nend\n</code></pre>"},{"location":"pluggable.html#instance_1","title":"Instance","text":"<p>You can easily mock any dependency of an initializable class using the custom initialization. You don't need to mock all the dependencies. Mock only the ones you need to make sure that the class works correctly. The others will be resolved from the registry as usual.</p> app/services/create_user_service.rb<pre><code>class CreateUserService\ninclude Aux::Pluggable\nresolve :users_repository, as: :repository\nresolve :preferences, -&gt; (preferences) { preferences.fetch(:default) }, as: :default_preferences\ndef call(**attributes)\nrepository.create!(**attributes, preferences: default_preferences)\nend\nend\n</code></pre> spec/services/create_user_service_spec.rb<pre><code>RSpec.describe(CreateUserService) do\nsubject(:service) { described_class.new(users_repository: users_repository) }\nlet(:users_repository) { double(:users_repository) }\nbefore do\nallow(users_repository).to receive(:create!)\nend\ndescribe '#call' do\nsubject!(:call) { service.call(**attributes) }\nlet(:attributes) do\n{\nemail: 'pluggable@aux.tld'\n}\nend\nit 'creates a new user' do\nexpect(users_repository).to have_received(:create!)\nend\nend\nend\n</code></pre>"}]}